---
title: 网络层
date: 2025-05-31 15:57:00
categories:
  - 计算机
tags:
  - 计算机网络
mathjax: "true"
---
# 计算机网络的核心功能  

## 核心功能  
- 互联：将不同类型的网络连接在一起，使得他们对传输层呈现统一的特征  
- 编址：让主机/路由器的地址在网络中唯一，两个不同的设备永远不能有同样的地址  
- 组包：将上层传输下来的数据封装为包，在互联网中由IP协议完成这项工作  
- 分段：由于不同的数据链路层协议支持的最大数据长度不同，网络层需要能够将包分为不同长度的段  
- 路由：决定将包送到哪一条，由路由器决定  
本文的行文脉络也将根据核心功能的顺序展开~  

## 对上层提供的服务  
虚电路：面向连接的服务。需要先建立连接，然后选择路由节点。但是需要带一个VCI的标识，以便转发  
数据报：面向无连接的服务，需要携带完整IP。  
两种服务的对比：  
![服务](/IMG/Pasted%20image%2020250509150208.png)  

# 路由  

## 基本概念  
1、最优化原则：如果节点J在节点I-K的最短路径上，那么J-K的最短路径也是I-K的最短路径的一部分，即最优路径上任意两点之间的路径也是最优的。  
![](/IMG/Pasted%20image%2020250509152038.png)  
2、汇集树：以目的节点为根，所有源节点到目的节点的最优路径构成的数。(可以理解为是目的节点的路由表的树形表达)  
![](/IMG/Pasted%20image%2020250509152331.png)  
3、泛洪(flooding)：将收到的包，发送给所有邻居。(一般用于路由表还没有完全建好的时候)  

## 静态路由算法  
由网络管理员手动设计，十分繁琐  

## 动态路由算法  

### 距离向量路由算法(DVR)  
1、基于Bellman-Ford算法发展而成  
2、Bellman-Ford算法的基本思想：$$  
d_x(y) = min(c(x,v)+d_v(y))  
$$其中，$c(x,v)$是邻居x到v的距离，$d_v(y)$是节点v到节点y的最短路径的总距离  
基于此，每个节点只需要维护以下数据：  
- 从x到其每个直接相连的邻居的直接距离  
- 节点x的距离向量(其到剩余所有节点的距离)  
- 它收到的每个邻居的距离向量  
3、算法运行过程：  
1) 节点定期的向每个邻居发送他的距离向量副本  
2) 节点每收到一个距离向量副本，就尝试运行Bellman-Ford算法更新自己的距离向量  
3) 如果更新成功，立刻向所有邻居发送更新过的距离向量副本  
4、问题：需要维护的表过于庞大，**收敛速度慢 ：可以理解为，其余节点的距离向量也不一定准确，因此收敛非常慢，而且易产生环路**  

### 链路状态路由算法(LSR)  
1、基于Dijkstra算法发展而成  
2、中心思想是，每个路由节点需要知道其余所有路由节点的拓补信息，然后调用Dijkstra算法。  
3、算法运行过程  
1) 节点定期测试和它的所有邻居的距离  
2) 在拓补变化的时候，将测试得到的距离通过泛洪发送给网络中的所有路由节点  
3) 通过其余节点的信息，建立整个网络拓补图  
4) 算出最短路径  
![](/IMG/Pasted%20image%2020250509155650.png)  
4、问题：每次运行占用的网络资源过大  

| **特性**     | **DVR (距离向量)**  | **LSR (链路状态)**      |  
| ---------- | --------------- | ------------------- |  
| **信息交换方式** | 周期性广播邻居的完整距离向量  | 洪泛传播链路状态信息（仅拓扑变化时）  |  
| **拓扑视图**   | 仅了解邻居的局部信息      | 全局拓扑视图（所有节点共享 LSDB） |  
| **计算复杂度**  | 低（仅需简单比较更新）     | 高（需运行 Dijkstra 算法）  |  
| **收敛速度**   | 慢（依赖逐跳传播）       | 快（全局信息同步）           |  
| **资源消耗**   | 低（内存和 CPU 开销较小） | 高（需存储 LSDB 并运行复杂计算） |  
| **环路问题**   | 易产生环路（需防环机制）    | 无环（Dijkstra 算法保证）   |  
| **典型协议**   | RIP（旧版）、IGRP    | OSPF、IS-IS          |  

### 层次选路  
1、其并非一种实际的算法，而是一个思想。即将网络划分区域，避免每次都需要获取整个网络的拓补。我只需要知道这个包需要发送到哪个区域，然后算出到那个区域的最短路径后，区域内再执行路由算法即可。  
缺点：并非最优路径  

## 拥塞控制  
1、原因：资源不足，处理时间过慢等因素造成包阻塞  
2、解决方案主要分为两种，一种是开源，一种是节流。开源类型的解决方案过于简单，不做主要论述，主要就是增加网络供给和增加业务量感知路由  
下面讨论节流类型的方法  

### 流量限制  
1、第一步：通过下面这个公式确定拥塞发生$$d_{new} = \alpha d_{old}+(1-\alpha)s$$  其中，d是最近的队列长度，s是采样得到的瞬间的队列长度。这个方法可以得到平滑的队列长度。  
2、第二步：通知发送方发生拥塞  
3、第三步：发送方调整发送速率  

对于第二步，通知发送方发生拥塞这一步，有两个方法  
ECN显式拥塞通知：在发送过程中，只要有路由器检测到拥塞，就会对packet中特定的控制字段进行修改。然后如果在接收方接收到被修改过的packet控制字段，就会返回一个显式的信号给到发送方。  
发送抑制分组通知：路由器向源主机以低速率发送抑制分组，原发生拥塞的包被标记，不会在后续的路由器产生更多的抑制分组。  

### 负载掉落  
说白了就是丢掉一些包。当包阻塞的时候，路由器直接就把他们扔了。  
所以关键之处在于，该丢掉哪些包？  
RED(早期随机检测)：当包的数量堆积超过阈值，那么此时开始随机丢包。  
由于数据链路层协议的设计，此时接收方会收到连续的同一帧的ACK，所以隐式地通知了接收方一些包被丢掉了。  

## QoS参数  
和第一章一样，但是这里不再以比特位单位，而是以包为单位  
1、可靠性：包丢失率和包错误率  
2、时延  
3、抖动  
4、带宽  
![](/IMG/Pasted%20image%2020250509164141.png)  
综上，不同的服务对QoS有不同的要求，但核心问题在于，怎么改进QoS  

### 流量整形法  
现象：主机以不规律的方式发包，容易导致拥塞  

#### 漏桶算法  
![](/IMG/Pasted%20image%2020250509164523.png)  
如图所示，Packet原来是以不同的速率发出的，但是在和实际网络拓补的接入点之间，插入了一个缓冲区，它像一个桶一样，接收所有的不规律速率的包，然后以一个标准的速率向外转发包。就像是打点滴的时候那个滴水的东西一样。这样就控制了流量的平滑性  

#### 令牌桶算法  
![](/IMG/Pasted%20image%2020250509164717.png)  
令牌桶算法的过程是这样的，每隔一段时间，令牌桶中会以一个确定的速度产生令牌，每个令牌相当于一个“传输许可证”，缓冲区中的包只要有令牌，就可以往外传。如果此时的令牌是有冗余的，那么这个包就会以一个很快的速率往外传，如果没令牌了，立刻就会降速到令牌产生的速度。  
以下为一个例子：  
![](/IMG/Pasted%20image%2020250509165151.png)  
下面是考试的重点，要会计算经过令牌桶之后的突发数据的持续时间。公式：$$B+RS = MS$$  
其中，B是令牌桶中令牌的存量(单位为byte)，S是以最大速率运行的时间，R是令牌的产生速率，M是最大的输出速率。这个公式的意思是，令牌桶中存有的令牌数量，加上突发的时间到来的可以产生的令牌总量，要等于以最大输出速率输出的总字节数。  

### 包规划法  
来自不同流的包来到同一个路由器，路由器可以以不同的方式对待这些流量来增加QoS  

#### FIFO  
最简单的模型，先到的包先出  

#### 优先级队列 PQ  
在原队列之外，设置一个优先级队列。用一个判断器，判断收到的包是重要的包还是不重要的，然后将包丢入对应的队列中。  
系统空闲时，将优先处理高优先级的数据，让他们先发送。  
但是这样会对低优先级队列不公平。  

#### 公平队列  
![](/IMG/Pasted%20image%2020250509170211.png)  
路由器为每个流分配相应的队列，采用轮询的方式发送包。  
但是根据mmr模型，这样会对小包不公平  

#### 公平加权队列  
![](/IMG/Pasted%20image%2020250509170349.png)  
每个队列有不同的权值，在公平队列的基础上，对于权值高的队列，每次轮询到它的时候，就处理多次它的包。  
![](/IMG/Pasted%20image%2020250509170458.png)  
下面这张图展示了公平队列模型的表格计算，基本必考。  
公式说明：  
$$  
F_i = max(A_i,F_{i-1})+\frac{L_i}{W}  
$$其中，$F_i$代表Packet i的完成时间，$A_i$为这个包的到达时间，$L_i$为这个包的长度，$W$为权重  
这个公式的意思是，在上一个包的完成时间和这个包的到达时间中取最大值作为开始传输的时间，然后加上传输的总时间，即得这个Packet的传输完成的时刻。  

# 互联  
现在我们使用的internet一般都有两个及以上的网络接入。  
对于网络层而言，网络的主要的不同主要在于地址和允许的最大传输单元。  
那么很显然的问题就是，如何屏蔽掉不同网络之间的差异然后传输呢？  

## 隧道技术  
如果源主机和目的主机都使用同一协议，但是他们之间的网络都是其他协议的，那么，隧道技术将把源主机的数据再度封装进中间网络的协议传输，也即二次封装。  
![](/IMG/Pasted%20image%2020250531194204.png)  

## 二级路由  
在互联网中，使用了二级路由算法。互联网被分为一个个独立的自洽系统(AS)，这些自洽系统内部由一个独立的组织管理  
1. **两级路由架构**  
    - **第一级（域内路由）**  
        - 在**每个网络内部**，使用**内部网关协议(Interior Gateway Protocol, IGP)** 进行路由。  
        - 例如：RIP、OSPF等协议负责网络内部的数据包转发。  
    - **第二级（域间路由）**  
        - 在**不同网络之间**（如互联网中的多个自治系统），使用**外部网关协议（Exterior Gateway Protocol, EGP）** 进行路由。  
        - 例如：BGP协议用于跨网络的数据包传输。  

下面我们将展开各个协议  

### RIP协议  
- **协议类型**  
  - Routing Information Protocol (RIP)  
  - 直接实现距离向量路由算法  
  - IGP  

- **路径成本**  
  - 基于跳数（Hop Count）  
  - 所有网络视为等同，每经过一个网络计为1跳  

- **限制与缺陷**  
  - 跳数最大值为16（16表示不可达）  
  - 网络规模受限，缺乏可扩展性  

- **通信方式**  
  - 通过UDP数据包传输RIP消息  

### OSPF 协议  
- **协议类型**  
  - 动态路由协议，用于IP网络自动计算最佳路径  
  - IGP  

- **基础机制**  
  - 基于链路状态路由（Link State Routing）  
  - 路由器收集邻居信息并广播，构建全网拓扑视图  

- **成本分配**  
  - 管理员可按服务类型（如带宽、延迟）为网络分配成本值(边的权重)  

- **拓扑同步**  
  - 所有路由器实时维护一致的网络拓扑信息  

- **高级功能支持**  
  - 服务类型路由、负载均衡、认证等  

- **消息传输**  
  - OSPF消息直接封装在IP数据包中传输（无需额外传输层协议）  

### RIP 与 OSPF 的核心对比  

| **对比维度**   | **RIP**                   | **OSPF**                   |  
| ---------- | ------------------------- | -------------------------- |  
| **协议类型**   | 距离向量路由协议（Distance Vector） | 链路状态路由协议（Link State）       |  
| **成本计算**   | 仅基于**跳数**（最大16跳，16表示不可达）  | 基于**链路状态**（可自定义成本值，如带宽、延迟） |  
| **网络规模**   | 适合小型网络（受限于跳数）             | 适合中大型网络（支持分层设计，扩展性强）       |  
| **收敛速度**   | 较慢（依赖周期性更新）               | 快速（仅在拓扑变化时触发更新）            |  
| **路由表维护**  | 全网同步完整路由表                 | 每个路由器维护局部链路状态数据库           |  
| **配置复杂度**  | 简单（无需手动配置成本值）             | 复杂（需划分区域、调整成本值）            |  
| **典型应用场景** | 小型局域网（如办公室网络）             | 大型企业网、ISP骨干网               |  

### BGP 协议(外部网关协议)  
1. **定义**  
    - **BGP**（Border Gateway Protocol，边界网关协议）是一种**路径矢量路由协议**，主要用于不同**自治系统（AS）** 之间的路由选择。  
2. **工作原理**  
    - **算法基础**：基于**距离向量算法**，但扩展了额外信息。  
    - **路径存储**：对每条路由存储**完整路径信息**（包括所有经过的自治系统），无需额外计算，仅需额外存储空间。  
3. **核心优势**  
    - **策略路由**：支持灵活策略（如避开特定AS、优先高带宽链路、避免拥塞）。  
    - **环路避免**：通过完整路径记录天然避免路由环路。  
    - **可靠传输**：基于**TCP协议**（端口179）传输消息，确保通信可靠性。  

# IPv4协议(完成组包，分片，编址工作)  
由于网络层的组包，分片和编制工作基本都由IP协议完成，因此不再沿用之前的思路，直接开始介绍IP协议。  

## IP头内容解析  
![](/IMG/Pasted%20image%2020250531205042.png)  

- Version:版本号，4比特长度，IPv4固定为4。表明使用的版本是IPv4  
- Header Length:4比特长度，表示数据头长度，需要乘以4字节。比如，如果这里的数字是15，就表示首部长度为60字节  
- Type of Service: 8比特长度，用于提供QoS服务的，可以提高包的传输优先级。也可以实现显式的拥塞通知  
- Total Length：整个IP包的长度(含有头)，单位为字节  
- Identifier：端到端传输过程中，在足够长的传输时间内，被分段过的包的标识是相等且唯一的。  
- Flags：三个标志位，第一位是保留位，没用。第二位是DF位，表示是否允许分段。第三位是MF位，表示是否还有更多的分段。  
- Fragmented Offset: 13位的长度。用于标识该分段包**之前**有多少字节的数据(不包括IP头)。该信息主要用于定位并重组包。需要乘以8，单位为字节。（由此得知，分片之后，数据部分的长度必须为8的倍数）  
- TTL: 该包可以存活多少跳。防止找不到目的主机而一直死循环在网络中，占用网络资源。  
- Protocol: 指明上层协议，包括ICMP，TCP，UDP等等...  
- Header CueckSum: 首部校验和，用于判断IP的协议头是否传输正确  
- Source Address：源地址  
- Distination Address：目的地址  

## 分段功能  
![](/IMG/Pasted%20image%2020250531222345.png)  
主要利用DF，MF以及Fragmented Offset这几位来操作。  
对于一般的题目而言，可以先根据MTU来计算出每一片的数据量。然后再算出一共要分几段即可。  

## 编址  
IP协议利用32位数据来记录地址。总空间是0.0.0.0~255.255.255.255。  
为了便于区分不同类型的地址的网络号和主机号的对应的位置，我们利用掩码来完成这个事情。只需要将IP地址和掩码做与运算，就可以得到网络号。  
在路由选择的过程中，无需主机号，只需要网络号就可以完成路由。  

### 地址类型  
- Classful分类编制：将网络空间分为A,B,C,D,E五类网。每类地址具有固定的网络部分和主机部分的长度。如下所示： ![](/IMG/Pasted%20image%2020250531224058.png)  
很容易得知：  
A类地址的掩码为:255.0.0.0  
B类为255.255.0.0  
C类为255.255.255.0  
- Classless：不固定网络部分和主机部分的长度，更加灵活，适用于子网划分和路由聚合。  主要代表为CIDR编址  
无类别网络的核心思想，是利用掩码的变长性质来更灵活的定义网络。CIDR编址就是利用掩码，指出网络部分的长度。然后就可以利用与操作计算出后续的主机的长度。![](/IMG/Pasted%20image%2020250602202115.png)  
![](/IMG/Pasted%20image%2020250602201815.png)  


**这里需要注意，如果要计算网内的可分配地址，那么在网络号定死之后，主机号中的全0地址和全1地址，都无法给主机使用，因为一个是网络地址，一个是默认的广播地址，它们已经被分配好了，所以可分配地址数是$2^n -2$，其中n为主机号的位数**  

### 唯一性和独立性  
- 每个网络接口都有一个唯一的 IPv4 地址，该地址与其物理地址无关，但定义了一个通用的互联网连接。  
- 如果一个主机或路由器有多个网络接口连接到互联网，则每个接口需要一个独立的 IPv4 地址。  

### 子网划分与子网掩码  
为了提高网络的利用率，我们可以将一个大网络的主机号，再构成一个小网络。小网络的划分对外部不可见，从而使得其不改变原有的网络拓补。  
在引入子网划分后，从主机ID中借用一部分位作为子网ID（Subnetid），从而形成三级层次结构：站点ID（Site）、子网ID（Subnetid）和主机ID（Hostid）。  
举例：141.14.0.0是一个大网络，我可以将它分为：141.14.192.0这个网络和141.14.191.0这个网络。以此类推，还可以有许多个小网络。  
子网掩码：  
就是在原来的掩码的基础上，为了让子网的划分能够可见，可以添加子网掩码，如下所示  
![](/IMG/Pasted%20image%2020250531225657.png)  
这张图中的子网，在原来的网络之外又额外使用了三位来划分子网。  
以下为子网划分的例子  
![](/IMG/Pasted%20image%2020250531225937.png)  

### 超网划分  
超网划分可以看作是子网划分的逆过程。对于很多个共享一部分网络号的很小的网络而言，如果它们都通过同一个路由，我们便可以把他们划分到同一个大的网络下，实现更好的管理。可以优化地址的分配，方便企业内部的管理。  
超网划分主要是为了解决Classful分类编址中，C类网过于零碎的问题。  
![](/IMG/Pasted%20image%2020250602200319.png)  

### 路由聚合  
路由聚合是适用于Classless类型的网络的，一种减少路由表条目的算法。  
对于CIDR编址，容易出现以下这种情况  
![](/IMG/Pasted%20image%2020250602202436.png)  
只要前面有一部分相同的地址，并且他们通过同一个路由器，就可以将这些地址聚合在一起，然后减少路由表的条目。  
但是这样也容易带来一个严峻的问题，就是比如上图中，它将网络聚合为192.24.000xxxxx.x/19这样的网络  
但是，实际上192.24.000xxxxx.x/19并非所有的网络，都在这个路由中，它还会有其他的部分散落在其他的网络中。比如192.24.00001100.0  
解决方法：根据最长掩码匹配原则，我们允许路由前缀的重叠，按照最具体的路由方向来转发即可。  
![](/IMG/Pasted%20image%2020250602202926.png)  
如图所示，我们便可以用更具体的IP来指代那些未被聚合的部分。  
因此我们也可以知道，聚合，最好是聚合多一点，这样路由表减少的条目就会多一点。  

### 主机路由和网络路由  
![](/IMG/Pasted%20image%2020250602204528.png)  
如图所示，左侧为主机路由，右侧为网络路由。  
对于主机路由而言，需要对每个特定的主机给出其对应的路由表。路由表膨胀较为严重。（掩码一定为255.255.255.255）  
相比较而言，对于网路路由而言，只需要给出下一个网络的位置即可。  
因此主机路由更适合细粒度网络，而网路路由适合管理大规模网络。  

### 缺省路由  
缺省路由的默认地址为0.0.0.0，每个路由器都需要有这样的一个路由条目，用于将未明确指定目的地址的包(包括没有匹配条目的)转发出去。  

以下给出一个完整的路由表示例  
![](/IMG/Pasted%20image%2020250602205339.png)  
若为本地网络，则无需下一条信息，直接转发即可。如果是其他网络的，则需要根据转发表，将其转发到对应的路由器。  

### 路由表内容总结  
- 主要信息：  
	- **下一跳（Next hop）**：数据包在转发过程中的下一个**路由器**地址  
	- **出接口（Outgoing line）**：数据包应通过哪个物理接口发送。  
	- **子网掩码（Netmask）**：用于确定目标地址所属的网络部分。  
	- **目的地址**：目标网络或主机的地址  
- 路由选择过程  
	- **掩码匹配**：路由器将数据包的**目的地址**与路由表中的**掩码**进行按位与运算，计算出目标网络地址。  
	- **查找匹配条目**：若路由表中存在匹配的条目（包括**默认路由**），则根据条目中的**出接口**和**下一跳地址**转发数据包。  
	- **无匹配条目的处理**：若未找到匹配条目且没有默认网关，数据包将被**丢弃**，并生成一个**ICMP错误报告消息**返回给源主机。  
	- **多匹配条目的处理**：根据最长掩码匹配规则进行处理  

# NAT桥接协议  
为了节省IP地址资源，很多企业内部通信使用内部网，对外只呈现为一个IP地址。因此，需要一种技术来将内部IP和外部IP进行链接。使得内部IP可以正常和外部通信。  
![](/IMG/Pasted%20image%2020250602210851.png)  
上图为所有的私有地址IP。  

## NAT过程  

### 向外访问的包  
将所有的内部网络连接到NAT路由器，NAT路由器将内网IP和一个端口建立映射关系，写入映射表。然后将该包的发出IP改写为对应的公网IP和对应的端口，同时**重算checksum**。然后正常转发改包。  

### 外部返回的包  
外部返回的包中会含有对应的端口。NAT路由器根据收到的端口号，将公网IP转化为内网IP，送入内网的对应主机中。  

### 动态NAT和静态NAT的区别  
当内部和外部的连接结束后，动态NAT会释放之前映射的端口。因此，动态NAT不支持外网设备直接申请访问内网，仅支持内网向外建立连接后相互通信。  
而静态NAT的映射关系提前由管理员分配。并且一般情况下不会变动。因此支持外网设备直接访问内网。  

# IPv6  
主要掌握IPv4和IPv6之间的变动和主要原因就可以了  

## 1. 保留的字段（与IPv4相同）  

- **版本（Version）**：标识协议版本（IPv4/IPv6），保留不变。  
- **源地址（Source Address）和目的地址（Destination Address）**：保留，但IPv6地址长度从32位扩展到128位。  

## 2. 移除的冗余字段  

- **IHL（Internet Header Length）**：IPv4中用于标识可变长度头部，在IPv6中被移除，因其头部固定为**40字节**。  
- **Header Checksum（头部校验和）**：移除，以减少处理开销，错误控制由数据链路层和传输层（如TCP/UDP）承担。  
- **Options（选项）**：功能被转移到**扩展头部**（Extension Headers）中实现。  

## 3.被替换的字段  

| **IPv4字段**                               | **IPv6对应字段/功能**          | **变化说明**                              |  
| ---------------------------------------- | ------------------------ | ------------------------------------- |  
| **Type of Service**                      | **Priority (PRI)**       | 替换为优先级字段，用于流量分类和QoS管理。                |  
| **Total Length**                         | **Payload Length**       | 表示数据部分长度（不含固定头部），而非整个IP包长度。           |  
| **Identification/Flags/Fragment Offset** | **Next Header + 分片扩展头部** | 分片功能由扩展头部实现，IPv6不再在基础头部保留这些字段。        |  
| **Time to Live (TTL)**                   | **Hop Limit**            | 功能相同，但字段名称和计数方式优化，限制数据包的跳数。           |  
| **Protocol**                             | **Next Header**          | 标识后续数据类型（如TCP/UDP），替代IPv4的Protocol字段。 |  

## IPv6数据报  

![](/IMG/Pasted%20image%2020250602214345.png)  
分为了基础头和拓展头。  
基础头中只保留最基本的网络功能需要的内容，拓展头中进行分片等操作。  
IP地址被拓展为128位。采用冒分十六进制表示  
![](/IMG/Pasted%20image%2020250602215154.png)  

# ARP协议  
- 位置：ARP协议位于网络层和数据链路层之间，核心业务是将IP地址解析为物理地址（MAC地址），是局域网通信的基础。  
- 和IP协议的关系：ARP协议可以理解为IP协议的辅助协议。IP协议本身不处理MAC地址的解析，而是依赖ARP完成这一任务。但是ARP协议本身是独立于IP协议的。  
- 工作过程：在数据链路层广播发送一个ARP请求报文，询问：“谁拥有IP地址X.X.X.X？”，报文内容包含源MAC和源IP地址（为了收到回复），以及目的IP地址。当收到目的主机的单播回复之后，将内容存入MAC-IP键值缓存中。  

# ICMP协议  
![](/IMG/Pasted%20image%2020250602220550.png)  
如图所示，ICMP格式的报文被封装在数据部分中。  
ICMP的控制类型主要包括：  
- 拥塞控制：源抑制  
- 重定向：更改包的路由路径  
- ECHO请求与响应：通常用于检查目的地是否可达。  
- 时间戳请求与响应  
- 路由器通告/请求：主机用来发现附近的路由器。  

# DHCP协议  
DHCP协议的主要目的是为局域网内的主机分配IP地址。  
其主要工作过程如下：  
![](/IMG/Pasted%20image%2020250602221005.png)  
如图所示  
1、Discover:首先由主机在局域网内发送广播包，用于寻找DHCP服务器。  
2、Offer包:DHCP服务器收到Discover请求后，广播地回复Offer包，告知其自己可以分配的IP地址。（这里，DHCP包是包含MAC地址的，所以可以知道分配给了谁）  
3、Request包:由于局域网内肯能存在多个DHCP服务器，因此，客户端选择自己心仪的IP地址后，为了防止DHCP资源的浪费，需要广播地回复一个Request包，告知局域网内所有服务器，自己选择了哪个DHCP服务器的Offer，接受了哪个IP。  
4、ACK包:在收到Request包之后，对应的DHCP服务器需要给客户端回一个ACK包，告知客户端自己已经成功为它分配了资源。客户端收到消息，至此，IP地址才正式完成分配。  

# 总层次总结  

![](/IMG/Pasted%20image%2020250531204257.png)  