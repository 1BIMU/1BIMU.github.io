---
title: 网络层
date: 2025-05-31 15:57:00
categories:
  - 计算机
tags:
  - 计算机网络
mathjax: "true"
---
# 计算机网络的核心功能  

## 核心功能  
- 互联：将不同类型的网络连接在一起，使得他们对传输层呈现统一的特征  
- 编址：让主机/路由器的地址在网络中唯一，两个不同的设备永远不能有同样的地址  
- 组包：将上层传输下来的数据封装为包，在互联网中由IP协议完成这项工作  
- 分段：由于不同的数据链路层协议支持的最大数据长度不同，网络层需要能够将包分为不同长度的段  
- 路由：决定将包送到哪一条，由路由器决定  
本文的行文脉络也将根据核心功能的顺序展开~  

## 对上层提供的服务  
虚电路：面向连接的服务。需要先建立连接，然后选择路由节点。但是需要带一个VCI的标识，以便转发  
数据报：面向无连接的服务，需要携带完整IP。  
两种服务的对比：  
![服务](/IMG/Pasted%20image%2020250509150208.png)  

# 路由  

## 基本概念  
1、最优化原则：如果节点J在节点I-K的最短路径上，那么J-K的最短路径也是I-K的最短路径的一部分，即最优路径上任意两点之间的路径也是最优的。  
![](/IMG/Pasted%20image%2020250509152038.png)  
2、汇集树：以目的节点为根，所有源节点到目的节点的最优路径构成的数。(可以理解为是目的节点的路由表的树形表达)  
![](/IMG/Pasted%20image%2020250509152331.png)  
3、泛洪(flooding)：将收到的包，发送给所有邻居。(一般用于路由表还没有完全建好的时候)  

## 静态路由算法  
由网络管理员手动设计，十分繁琐  

## 动态路由算法  

### 距离向量路由算法(DVR)  
1、基于Bellman-Ford算法发展而成  
2、Bellman-Ford算法的基本思想：$$  
d_x(y) = min(c(x,v)+d_v(y))  
$$其中，$c(x,v)$是邻居x到v的距离，$d_v(y)$是节点v到节点y的最短路径的总距离  
基于此，每个节点只需要维护以下数据：  
- 从x到其每个直接相连的邻居的直接距离  
- 节点x的距离向量(其到剩余所有节点的距离)  
- 它收到的每个邻居的距离向量  
3、算法运行过程：  
1) 节点定期的向每个邻居发送他的距离向量副本  
2) 节点每收到一个距离向量副本，就尝试运行Bellman-Ford算法更新自己的距离向量  
3) 如果更新成功，立刻向所有邻居发送更新过的距离向量副本  
4、问题：需要维护的表过于庞大，收敛速度慢  

### 链路状态路由算法(LSR)  
1、基于Dijkstra算法发展而成  
2、中心思想是，每个路由节点需要知道其余所有路由节点的拓补信息，然后调用Dijkstra算法。  
3、算法运行过程  
1) 节点定期测试和它的所有邻居的距离  
2) 将测试得到的距离通过泛洪发送给网络中的所有路由节点  
3) 通过其余节点的信息，建立整个网络拓补图  
4) 算出最短路径  
![](/IMG/Pasted%20image%2020250509155650.png)  
4、问题：每次运行占用的网络资源过大  

### 层次选路  
1、其并非一种实际的算法，而是一个思想。即将网络划分区域，避免每次都需要获取整个网络的拓补。我只需要知道这个包需要发送到哪个区域，然后算出到那个区域的最短路径后，区域内再执行路由算法即可。  
缺点：并非最优路径  

## 拥塞控制  
1、原因：资源不足，处理时间过慢等因素造成包阻塞  
2、解决方案主要分为两种，一种是开源，一种是节流。开源类型的解决方案过于简单，不主要论述，主要就是增加网络供给和增加业务量感知路由  
下面讨论节流类型的方法  

### 流量限制  
1、第一步：通过下面这个公式确定拥塞发生$$d_{new} = \alpha d_{old}+(1-\alpha)s$$  
2、第二步：通知发送方发生拥塞  
3、第三步：发送方调整发送速率  

对于第二步，通知发送方发生拥塞这一步，有两个方法  
ECN显式拥塞通知：在发送过程中，只要有路由器检测到拥塞，就会对packet中特定的控制字段进行修改。然后如果在接收方接收到被修改过的packet控制字段，就会返回一个显式的信号给到发送方。  
发送抑制分组通知：路由器向源主机以低速率发送抑制分组，原发生拥塞的包被标记，不会在后续的路由器产生更多的抑制分组。  

### 负载掉落  
说白了就是丢掉一些包。当包阻塞的时候，路由器直接就把他们扔了。  
所以关键之处在于，该丢掉哪些包？  
RED(早期随机检测)：当包的数量堆积超过阈值，那么此时开始随机丢包。  
由于数据链路层协议的设计，此时接收方会收到连续的同一帧的ACK，所以隐式地通知了接收方一些包被丢掉了。  

## QoS参数  
和第一章一样，但是这里不再以比特位单位，而是以包为单位  
1、可靠性：包丢失率和包错误率  
2、时延  
3、抖动  
4、带宽  
![](/IMG/Pasted%20image%2020250509164141.png)  
综上，不同的服务对QoS有不同的要求，但核心问题在于，怎么改进QoS  

### 流量整形法  
现象：主机以不规律的方式发包，容易导致拥塞  

#### 漏桶算法  
![](/IMG/Pasted%20image%2020250509164523.png)  
如图所示，Packet原来是以不同的速率发出的，但是在和实际网络拓补的接入点之间，插入了一个缓冲区，它像一个桶一样，接收所有的不规律速率的包，然后以一个标准的速率向外转发包。就像是打点滴的时候那个滴水的东西一样。这样就控制了流量的平滑性  

#### 令牌桶算法  
![](/IMG/Pasted%20image%2020250509164717.png)  
令牌桶算法的过程是这样的，每隔一段时间，令牌桶中会以一个确定的速度产生令牌，每个令牌相当于一个“传输许可证”，缓冲区中的包只要有令牌，就可以往外传。如果此时的令牌是有冗余的，那么这个包就会以一个很快的速率往外传，如果没令牌了，立刻就会降速到令牌产生的速度。  
以下为一个例子：  
![](/IMG/Pasted%20image%2020250509165151.png)  
下面是考试的重点，要会计算经过令牌桶之后的突发数据的持续时间。公式：$$B+RS = MS$$  
其中，B是令牌桶中令牌的存量(单位为byte)，S是以最大速率运行的时间，R是令牌的产生速率，M是最大的输出速率。这个公式的意思是，令牌桶中存有的令牌数量，加上突发的时间到来的可以产生的令牌总量，要等于以最大输出速率输出的总字节数。  

### 包规划法  
来自不同流的包来到同一个路由器，路由器可以以不同的方式对待这些流量来增加QoS  

#### FIFO  
最简单的模型，先到的包先出  

#### 优先级队列 PQ  
在原队列之外，设置一个优先级队列。用一个判断器，判断收到的包是重要的包还是不重要的，然后将包丢入对应的队列中。  
系统空闲时，将优先处理高优先级的数据，让他们先发送。  
但是这样会对低优先级队列不公平。  

#### 公平队列  
![](/IMG/Pasted%20image%2020250509170211.png)  
路由器为每个流分配相应的队列，采用轮询的方式发送包。  
但是根据mmr模型，这样会对小包不公平  

#### 公平加权队列  
![](/IMG/Pasted%20image%2020250509170349.png)  
每个队列有不同的权值，在公平队列的基础上，对于权值高的队列，每次轮询到它的时候，就处理多次它的包。  
![](/IMG/Pasted%20image%2020250509170458.png)  
下面这张图展示了公平队列模型的表格计算，基本必考。  
公式说明：  
$$  
F_i = max(A_i,F_{i-1})+\frac{L_i}{W}  
$$其中，$F_i$代表Packet i的完成时间，$A_i$为这个包的到达时间，$L_i$为这个包的长度，$W$为权重  
这个公式的意思是，在上一个包的完成时间和这个包的到达时间中取最大值作为开始传输的时间，然后加上传输的总时间，即得这个Packet的传输完成的时刻。  

# 互联  
现在我们使用的internet一般都有两个及以上的网络接入。  
对于网络层而言，网络的主要的不同主要在于地址和允许的最大传输单元。  
那么很显然的问题就是，如何屏蔽掉不同网络之间的差异然后传输呢？  

## 隧道技术  
如果源主机和目的主机都使用同一协议，但是他们之间的网络都是其他协议的，那么，隧道技术将把源主机的数据再度封装进中间网络的协议传输，也即二次封装。  
![](/IMG/Pasted%20image%2020250531194204.png)  

## 二级路由  
在互联网中，使用了二级路由算法。互联网被分为一个个独立的自洽系统(AS)，这些自洽系统内部由一个独立的组织管理  
1. **两级路由架构**  
    - **第一级（域内路由）**  
        - 在**每个网络内部**，使用**内部网关协议(Interior Gateway Protocol, IGP)** 进行路由。  
        - 例如：RIP、OSPF等协议负责网络内部的数据包转发。  
    - **第二级（域间路由）**  
        - 在**不同网络之间**（如互联网中的多个自治系统），使用**外部网关协议（Exterior Gateway Protocol, EGP）** 进行路由。  
        - 例如：BGP协议用于跨网络的数据包传输。  

下面我们将展开各个协议  

### RIP协议  
- **协议类型**  
  - Routing Information Protocol (RIP)  
  - 直接实现距离向量路由算法  
  - IGP  

- **路径成本**  
  - 基于跳数（Hop Count）  
  - 所有网络视为等同，每经过一个网络计为1跳  

- **限制与缺陷**  
  - 跳数最大值为16（16表示不可达）  
  - 网络规模受限，缺乏可扩展性  

- **通信方式**  
  - 通过UDP数据包传输RIP消息  

### OSPF 协议  
- **协议类型**  
  - 动态路由协议，用于IP网络自动计算最佳路径  
  - IGP  

- **基础机制**  
  - 基于链路状态路由（Link State Routing）  
  - 路由器收集邻居信息并广播，构建全网拓扑视图  

- **成本分配**  
  - 管理员可按服务类型（如带宽、延迟）为网络分配成本值(边的权重)  

- **拓扑同步**  
  - 所有路由器实时维护一致的网络拓扑信息  

- **高级功能支持**  
  - 服务类型路由、负载均衡、认证等  

- **消息传输**  
  - OSPF消息直接封装在IP数据包中传输（无需额外传输层协议）  

### RIP 与 OSPF 的核心对比  

|**对比维度**|**RIP**|**OSPF**|  
|---|---|---|  
|**协议类型**|距离向量路由协议（Distance Vector）|链路状态路由协议（Link State）|  
|**成本计算**|仅基于**跳数**（最大16跳，16表示不可达）|基于**链路状态**（可自定义成本值，如带宽、延迟）|  
|**网络规模**|适合小型网络（受限于跳数）|适合中大型网络（支持分层设计，扩展性强）|  
|**收敛速度**|较慢（依赖周期性更新）|快速（仅在拓扑变化时触发更新）|  
|**路由表维护**|全网同步完整路由表|每个路由器维护局部链路状态数据库|  
|**配置复杂度**|简单（无需手动配置成本值）|复杂（需划分区域、调整成本值）|  
|**典型应用场景**|小型局域网（如办公室网络）|大型企业网、ISP骨干网|  

### BGP 协议(EGP)  
1. **定义**  
    - **BGP**（Border Gateway Protocol，边界网关协议）是一种**路径矢量路由协议**，主要用于不同**自治系统（ASs）**之间的路由选择。  
2. **工作原理**  
    - **算法基础**：基于**距离向量算法**，但扩展了额外信息。  
    - **路径存储**：对每条路由存储**完整路径信息**（包括所有经过的自治系统），无需额外计算，仅需额外存储空间。  
3. **核心优势**  
    - **策略路由**：支持灵活策略（如避开特定AS、优先高带宽链路、避免拥塞）。  
    - **环路避免**：通过完整路径记录天然避免路由环路。  
    - **可靠传输**：基于**TCP协议**（端口179）传输消息，确保通信可靠性。  


# IPv4协议(完成组包，分片，编址工作)  
由于网络层的组包，分片和编制工作基本都由IP协议完成，因此不再沿用之前的思路，直接开始介绍IP协议。  

## IP头内容解析  
![](/IMG/Pasted%20image%2020250531205042.png)  
- Version:版本号，4比特长度，IPv4固定为4。表明使用的版本是IPv4  
- Header Length:4比特长度，表示数据头长度，需要乘以4字节。比如，如果这里的数字是15，就表示首部长度为60字节  
- Type of Service: 8比特长度，用于提供QoS服务的，可以提高包的传输优先级。也可以实现显式的拥塞通知  
- Total Length：整个IP包的长度(含有头)，单位为字节  
- Identifier：端到端传输过程中，在足够长的传输时间内，被分段过的包的标识是相等且唯一的。  
- Flags：三个标志位，第一位是保留位，没用。第二位是DF位，表示是否允许分段。第三位是MF位，表示是否还有更多的分段。  
- Fragmented Offset: 13位的长度。用于标识该分段包**之前**有多少字节的数据(不包括IP头)。该信息主要用于定位并重组包。需要乘以8，单位为字节。（由此得知，分片之后，数据部分的长度必须为8的倍数）  
- TTL: 该包可以存活多少跳。防止找不到目的主机而一直死循环在网络中，占用网络资源。  
- Protocol: 指明上层协议，包括ICMP，TCP，UDP等等...  
- Header CueckSum: 首部校验和，用于判断IP的协议头是否传输正确  
- Source Address：源地址  
- Distination Address：目的地址  

## 分段功能  
![](/IMG/Pasted%20image%2020250531222345.png)  
主要利用DF，MF以及Fragmented Offset这几位来操作。  
对于一般的题目而言，可以先根据MTU来计算出每一片的数据量。然后再算出一共要分几段即可。  

## 编址  
IP协议利用32位数据来记录地址。总空间是0.0.0.0~255.255.255.255。  
为了便于区分不同类型的地址的网络号和主机号的对应的位置，我们利用掩码来完成这个事情。只需要将IP地址和掩码做与运算，就可以得到网络号。  
在路由选择的过程中，无需主机号，只需要网络号就可以完成路由。  

### 地址类型  
- Classful分类编制：将网络空间分为A,B,C,D,E五类网。每类地址具有固定的网络部分和主机部分的长度。如下所示： ![](/IMG/Pasted%20image%2020250531224058.png)  
很容易得知：  
A类地址的掩码为:255.0.0.0  
B类为255.255.0.0  
C类为255.255.255.0  
- Classless：不固定网络部分和主机部分的长度，更加灵活，适用于子网划分和路由聚合。  

**这里需要注意，如果要计算网内的可分配地址，那么在网络号定死之后，主机号中的全0地址和全1地址，都无法给主机使用，因为一个是网络地址，一个是默认的广播地址，它们已经被分配好了，所以可分配地址数是$2^n -2$，其中n为主机号的位数**  

### 唯一性和独立性  
- 每个网络接口都有一个唯一的 IPv4 地址，该地址与其物理地址无关，但定义了一个通用的互联网连接。  
- 如果一个主机或路由器有多个网络接口连接到互联网，则每个接口需要一个独立的 IPv4 地址。  

### 子网划分与子网掩码  
为了提高网络的利用率，我们可以将一个大网络的主机号，再构成一个小网络。小网络的划分对外部不可见，从而使得其不改变原有的网络拓补。  
在引入子网划分后，从主机ID中借用一部分位作为子网ID（Subnetid），从而形成三级层次结构：站点ID（Site）、子网ID（Subnetid）和主机ID（Hostid）。  
举例：141.14.0.0是一个大网络，我可以将它分为：141.14.192.0这个网络和141.14.191.0这个网络。以此类推，还可以有许多个小网络。  
子网掩码：  
就是在原来的掩码的基础上，为了让子网的划分能够可见，可以添加子网掩码，如下所示  
![](/IMG/Pasted%20image%2020250531225657.png)  
这张图中的子网，在原来的网络之外又额外使用了三位来划分子网。  
以下为子网划分的例子  
![](/IMG/Pasted%20image%2020250531225937.png)  

### 超网划分  
超网划分可以看作是子网划分的逆过程。对于很多个共享一部分网络号的很小的网络而言，如果它们都通过同一个路由，我们便可以把他们划分到同一个大的网络下，实现更好的管理。具体的算法是路由聚合算法。  







![](/IMG/Pasted%20image%2020250531204257.png)  