---
title: 指令系统
date: 2025-05-03 08:00:41
categories:
  - 计算机
tags:
  - 计算机组成原理
mathjax: true
---

## 指令的格式与基本作用  

### 基本格式  
零地址指令：只给出操作码OP，没有显示地址  
一地址指令：操作码+地址  
二地址指令：操作码+源地址+目的地址  
三地址指令：操作码+源地址+目的地址+存入地址  
四地址指令：操作码+源地址+目的地址+存入地址+下一条指令地址  
特别的，为了提高指令识别的速度和译码效率，多数系统采用定长操作码指令格式  
同时，为了在有限的字长的情况下，使用更多的指令，我们可以采用可变长度操作码的方法，针对不同地址个数的指令，我们可以设计不同长度的操作码来兼容。只要保证最大字长不变即可  

### 操作类型  
数据传送：MOV，LOAD，STORE，PUSH，POP  
算术运算和逻辑运算：ADD,SUB,MUL,DIV,INC,DEC,AND,OR,NOT,XOR  
移位操作：算术移位，逻辑移位，循环移位  
转移操作：JMP，BRANCH，CALL，RET，TRAP  

## 寻址方式  

### 指令寻址  
即，寻找下一条指令的地址  
1、顺序寻址：PC寄存器中储存  
2、跳跃寻址：通过转移指令实现  

### 数据寻址  
即，如何表示一个操作数的地址  

#### 正常寻址方式  
1、隐含寻址：  
不给出操作数的地址，而是隐式的约定某个寄存器/硬件为操作数  
例: ADD![](/IMG/Pasted%20image%2020250612211016.png)  
公式：OP中隐含  
2、立即寻址：  
给出的不是操作数的地址，而是操作数本身。利用操作数本身（有符号数）直接运算  
示例：MOV AX, 1234H  
公式：操作数=A  
3、直接寻址：  
形式地址A就是真实地址EA，可以直接访问  
**公式**：`EA = A`  
**示例指令**：`MOV AX, [2000H]`  
4、间接寻址：（要访问两次主存，不好用）  
形式地址给出的不是真实地址，而是真实地址值在存储单元中的地址。  
**公式**：`EA = (A)`  
**示例指令**：`MOV AX, [[2000H]]`  
5、寄存器寻址：  
和直接寻址相似，只是把访问主存改为访问寄存器而已  
**公式**：`EA = R` （这里的EA指操作数的位置，即寄存器R本身）  
**示例指令**：`MOV AX, BX`  
6、寄存器间接寻址：  
和间接寻址相似，但是访问的是寄存器中储存的地址。  
**公式**：`EA = (R)`  
**示例指令**：`MOV AX, [BX]`  

#### 偏移寻址  
偏移寻址的意思是，从特定寄存器中取出一个地址，然后加上偏移量A（==有符号数==），最终得到完整地址。  
主要分为三种方式：  
7、相对寻址：  
寄存器为PC寄存器  
**公式**：`EA = (PC) + A`  
8、基址寻址：  
寄存器为基址寄存器  
**公式**：`EA = (BR) + A`  
9、变址寻址：  
寄存器为变址寄存器  
**公式**：`EA = (IX) + A`  
10、堆栈寻址  
隐含调用了sp寄存器来寻址  
**公式**：EA = (SP)  

特别注意：偏移寻址的范围，不算A的！因为，地址位的位数有上限，会取模！  
在考试或理论分析中，当基址/变址寄存器的位数远大于偏移量的位数时，通常认为这种寻址方式的**有效寻址范围就是由寄存器位数所决定的整个主存空间**。  

# RISC和CISC的特点  

![](/IMG/Pasted%20image%2020250614114151.png)![](/IMG/Pasted%20image%2020250614114218.png)  


### CISC 与 RISC 核心特点对比表  

| 对比维度      | CISC (复杂指令集计算机)           | RISC (精简指令集计算机)         | 记忆口诀           |  
| :-------- | :------------------------ | :---------------------- | :------------- |  
| **设计哲学**  | **硬件复杂，软件简单**             | **硬件简单，软件（编译器）复杂**      | 一个靠硬，一个靠软      |  
| **指令系统**  | 指令数量**多**、系统庞大 (200-300条) | 选取常用指令，数量**少** (<100条)  | 多而全 vs 少而精     |  
| **指令长度**  | **可变**长度，格式复杂             | **固定**长度，格式规整           | 长短不一 vs 整齐划一   |  
| **内存访问**  | **任何指令**都可能访问内存           | **仅 Load/Store** 指令访问内存 | 谁都能访 vs 专人负责   |  
| **通用寄存器** | 数量**较少**                  | 数量**较多**，减少访存           | 寄存器少 vs 寄存器多   |  
| **执行速度**  | 指令执行时间**差异大**             | 大部分指令在**单周期**内完成        | 快慢不均 vs 步调一致   |  
| **流水线**   | **不利于**流水线处理              | **易于**实现指令流水线           | 流水线困难 vs 流水线友好 |  
| **控制方式**  | **微程序**控制 (Microcode)     | **硬布线**逻辑 (Hard-wired)  | 微码控制 vs 硬线逻辑   |  
| **编译器**   | 优化**困难**，难生成高效代码          | 编译器**优化**起关键作用          | 编译器难 vs 编译器强   |  
| **过程调用**  | 主要靠**栈 (Stack)** 传递参数     | 主要靠**寄存器**传递参数，更高效      | 一个靠栈，一个靠寄存器    |  
