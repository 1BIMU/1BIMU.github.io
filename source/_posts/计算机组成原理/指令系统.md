---
title: 指令系统
date: 2025-05-03 08:00:41
categories:
  - 计算机
tags:
  - 计算机组成原理
mathjax: true
---

## 指令的格式与基本作用  

### 基本格式  
零地址指令：只给出操作码OP，没有显示地址  
一地址指令：操作码+地址  
二地址指令：操作码+源地址+目的地址  
三地址指令：操作码+源地址+目的地址+存入地址  
四地址指令：操作码+源地址+目的地址+存入地址+下一条指令地址  
特别的，为了提高指令识别的速度和译码效率，多数系统采用定长操作码指令格式  
同时，为了在有限的字长的情况下，使用更多的指令，我们可以采用可变长度操作码的方法，针对不同地址个数的指令，我们可以设计不同长度的操作码来兼容。只要保证最大字长不变即可  

### 操作类型  
数据传送：MOV，LOAD，STORE，PUSH，POP  
算术运算和逻辑运算：ADD,SUB,MUL,DIV,INC,DEC,AND,OR,NOT,XOR  
移位操作：算术移位，逻辑移位，循环移位  
转移操作：JMP，BRANCH，CALL，RET，TRAP  

## 寻址方式  

### 指令寻址  
即，寻找下一条指令的地址  
1、顺序寻址：PC寄存器中储存  
2、跳跃寻址：通过转移指令实现  

### 数据寻址  
即，如何表示一个操作数的地址  

#### 正常寻址方式  
1、隐含寻址：  
不给出操作数的地址，而是隐式的约定某个寄存器/硬件为操作数  
例: ADD![](/IMG/Pasted%20image%2020250612211016.png)  
公式：OP中隐含  
2、立即寻址：  
给出的不是操作数的地址，而是操作数本身。利用操作数本身（有符号数）直接运算  
示例：MOV AX, 1234H  
公式：操作数=A  
3、直接寻址：  
形式地址A就是真实地址EA，可以直接访问  
**公式**：`EA = A`  
**示例指令**：`MOV AX, [2000H]`  
4、间接寻址：（要访问两次主存，不好用）  
形式地址给出的不是真实地址，而是真实地址值在存储单元中的地址。  
**公式**：`EA = (A)`  
**示例指令**：`MOV AX, [[2000H]]`  
5、寄存器寻址：  
和直接寻址相似，只是把访问主存改为访问寄存器而已  
**公式**：`EA = R` （这里的EA指操作数的位置，即寄存器R本身）  
**示例指令**：`MOV AX, BX`  
6、寄存器间接寻址：  
和间接寻址相似，但是访问的是寄存器中储存的地址。  
**公式**：`EA = (R)`  
**示例指令**：`MOV AX, [BX]`  

#### 偏移寻址  
偏移寻址的意思是，从特定寄存器中取出一个地址，然后加上偏移量A（==有符号数==），最终得到完整地址。  
主要分为三种方式：  
7、相对寻址：  
寄存器为PC寄存器  
**公式**：`EA = (PC) + A`  
8、基址寻址：  
寄存器为基址寄存器  
**公式**：`EA = (BR) + A`  
9、变址寻址：  
寄存器为变址寄存器  
**公式**：`EA = (IX) + A`  
10、堆栈寻址  
隐含调用了sp寄存器来寻址  
**公式**：EA = (SP)  

特别注意：偏移寻址的范围，不算A的！因为，地址位的位数有上限，会取模！  
在考试或理论分析中，当基址/变址寄存器的位数远大于偏移量的位数时，通常认为这种寻址方式的**有效寻址范围就是由寄存器位数所决定的整个主存空间**。  

# RISC和CISC的特点  

![](/IMG/Pasted%20image%2020250614114151.png)![](/IMG/Pasted%20image%2020250614114218.png)  